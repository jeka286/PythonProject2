# 1 zadanie
# def s1():
#     # Алфавит 15-ричной системы счисления
#     digits = "0123456789ABCDEF"
#
#     # Перебираем все возможные значения x (от 0 до 14)
#     for x in range(15):
#         # Формируем числа как строки с текущим значением x
#         first_str = "123" + digits[x] + "5"  # 123x5₁₅
#         second_str = "1" + digits[x] + "233"  # 1x233₁₅
#
#         # Переводим первое число в десятичную систему
#         a = 0
#         for ch in first_str:
#             a = a * 15 + digits.index(ch)  # Умножаем на основание и добавляем значение цифры
#
#         # Переводим второе число в десятичную систему
#         b = 0
#         for ch in second_str:
#             b = b * 15 + digits.index(ch)
#
#         # Вычисляем сумму чисел
#         total = a + b
#
#         # Проверяем, делится ли сумма на 14
#         if total % 14 == 0:
#             # Находим частное от деления
#             quotient = total // 14
#
#             # Переводим частное обратно в 15-ричную систему
#             quotient_15 = ""
#             n = quotient
#             while n > 0:
#                 # Берем остаток от деления на 15 - это очередная цифра
#                 quotient_15 = digits[n % 15] + quotient_15
#                 n //= 15  # Целочисленное деление
#
#             # Возвращаем результат в десятичной и 15-ричной системах
#             return quotient, quotient_15
#
#
# # Получаем и выводим результат
# result_dec, result_15 = s1()
# print(result_dec)  # 8767 (в десятичной системе)
# print(result_15)  # 28E7 (в 15-ричной системе)

# 2 zadanie
# def find_min_p():
#     # Первое число: AB267D1p
#     # Второе число: F024A89p
#     # Буквы: A=10, B=11, D=13, F=15
#     # Максимальная цифра в обоих числах: F=15
#
#     # Значит p > 15, начинаем с p=16
#
#     for p in range(16, 100):  # Достаточно большой диапазон
#         # Переводим первое число AB267D1p в десятичную
#         # Цифры: A=10, B=11, 2, 6, 7, D=13, 1
#         digits1 = [10, 11, 2, 6, 7, 13, 1]
#         num1 = 0
#         for digit in digits1:
#             num1 = num1 * p + digit
#
#         # Переводим второе число F024A89p в десятичную
#         # Цифры: F=15, 0, 2, 4, A=10, 8, 9
#         digits2 = [15, 0, 2, 4, 10, 8, 9]
#         num2 = 0
#         for digit in digits2:
#             num2 = num2 * p + digit
#
#         # Сумма чисел
#         total = num1 + num2
#
#         # Проверяем, делится ли сумма на (p-1)
#         if total % (p - 1) == 0:
#             return p
#     return None
# # Находим минимальное p
# result_p = find_min_p()
# print(f"Минимальное основание p, при котором сумма делится на p-1: {result_p}")


# 3 zadanie
# def solve():
#     # Первое число: xB09 в 17-ричной системе
#     # Второе число: x8E8 в 15-ричной системе
#     # x - десятичная цифра (0-9)
#     # Проверяем условие делимости суммы на 155
#
#     for x in range(10):  # x от 0 до 9
#         # Переводим первое число xB09 из 17-ричной в десятичную
#         # Цифры: x, B=11, 0, 9
#         num1 = x * 17 ** 3 + 11 * 17 ** 2 + 0 * 17 ** 1 + 9
#
#         # Переводим второе число x8E8 из 15-ричной в десятичную
#         # Цифры: x, 8, E=14, 8
#         num2 = x * 15 ** 3 + 8 * 15 ** 2 + 14 * 15 ** 1 + 8
#
#         # Вычисляем сумму
#         total = num1 + num2
#
#         # Проверяем делимость на 155
#         if total % 155 == 0:
#             quotient = total // 155
#             return x, quotient
#
#     return None, None
#
#
# # Находим решение
# x_val, quotient = solve()
# print(f"Наименьшее x: {x_val}")
# print(f"Частное от деления на 155: {quotient}")

# 4 zadanie
# min_total = float('inf')
# result_quotient = None
# best_x = None
# best_y = None
#
# # Перебираем все возможные значения x и y
# for x in range(8):  # x может быть только 0-7 (т.к. во втором числе основание 8)
#     for y in range(8):  # y может быть только 0-7 (т.к. во втором числе основание 8)
#         # Также y и x должны быть допустимы в 11-ричной системе (0-10) - это выполняется для 0-7
#
#         # Первое число: y04x5 в 11-ричной системе
#         # Разряды: y * 11^4 + 0 * 11^3 + 4 * 11^2 + x * 11^1 + 5
#         num1 = y * 11 ** 4 + 4 * 11 ** 2 + x * 11 + 5
#
#         # Второе число: 253xy в 8-ричной системе
#         # Разряды: 2 * 8^4 + 5 * 8^3 + 3 * 8^2 + x * 8^1 + y
#         num2 = 2 * 8 ** 4 + 5 * 8 ** 3 + 3 * 8 ** 2 + x * 8 + y
#
#         total = num1 + num2
#
#         # Проверяем делимость на 117
#         if total % 117 == 0:
#             if total < min_total:
#                 min_total = total
#                 result_quotient = total // 117
#                 best_x, best_y = x, y
#
# print(f"Минимальная сумма: {min_total}")
# print(f"x = {best_x}, y = {best_y}")
# print(f"Частное от деления на 117: {result_quotient}")


# 5 zadanie
def c1():
    # Представим число в виде списка коэффициентов при степенях 8
    # Максимальная степень: 5736
    coeffs = [0] * (5737)

    # Добавляем положительные слагаемые
    coeffs[5736] += 7
    coeffs[3908] += 6

    # Вычитаем отрицательные слагаемые
    coeffs[1991] -= 5
    coeffs[1980] -= 4
    # -2022 в восьмеричной системе: 2022(10) = 3746(8)
    # 2022 = 3·8^3 + 7·8^2 + 4·8^1 + 6·8^0
    # Вычитаем это:
    coeffs[3] -= 3
    coeffs[2] -= 7
    coeffs[1] -= 4
    coeffs[0] -= 6

    # Приводим коэффициенты к диапазону 0..7 с переносами
    for i in range(len(coeffs)):
        if coeffs[i] < 0 or coeffs[i] >= 8:
            carry = coeffs[i] // 8
            coeffs[i] %= 8
            if i + 1 < len(coeffs):
                coeffs[i + 1] += carry
            elif carry != 0:
                coeffs.append(carry)

    # Коэффициенты теперь цифры восьмеричного числа
    # Обратный порядок: coeffs[0] - младший разряд
    # Перевернем для удобства
    digits = coeffs[::-1]

    # Считаем количество цифр 7
    count_7 = digits.count(7)

    return count_7, digits[:50]  # возвращаем первые 50 цифр для проверки


count_7, first_digits = c1()
print(f"Количество цифр 7 в восьмеричной записи: {count_7}")
print(f"Первые 50 цифр (старшие разряды): {first_digits}")